# python 正则表达式 常用函数

## **re.compile(strPattern[, flag])**

这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符`'|'`表示同时生效，比如`re.I | re.M`。另外，你也可以在regex字符串中指定模式，比如`re.compile('pattern', re.I | re.M)`与`re.compile('(?im)pattern')`是等价的。
可选值有：

- re.**I**(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）
- **M**(MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图）
- **S**(DOTALL): 点任意匹配模式，改变'.'的行为
- **L**(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定
- **U**(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性
- **X**(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：

```python
a = re.compile(r"""\d +  # the integral part
                   \.    # the decimal point
                   \d *  # some fractional digits""", re.X)
b = re.compile(r"\d+\.\d*")
```



## 1、match

```python
re.match(pattern, string[, flags])
```

从首字母开始开始匹配，string如果包含pattern子串，则匹配成功，返回Match对象，失败则返回None，若要完全匹配，pattern要以$结尾。



## 2、search

```python
re.search(pattern, string[, flags])
```

若string中包含pattern子串，则返回Match对象，否则返回None，注意，如果string中存在多个pattern子串，只返回第一个。
## 3、findall

```python
re.findall(pattern, string[, flags])
```

返回string中所有与pattern相匹配的全部字串，返回形式为数组。
## 4、finditer

```python
 re.finditer(pattern, string[, flags])
```

返回 string 中所有与 pattern 相匹配的全部字串，返回形式为迭代器。


若匹配成功，`match()` / `search()`返回的是Match对象，`finditer()`返回的也是Match对象的迭代器，获取匹配结果需要调用Match对象的`group()`、`groups`或`group(index)`方法。

## **5、split**

```python
split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]):
```

```python
import re
 
p = re.compile(r'\d+')
print p.split('one1two2three3four4')
 
### output ###
# ['one', 'two', 'three', 'four', '']
```



## `group()`、`groups()`与`group(index)`的区别

，如下所示：

```python
>>> import re
>>> s = '23432werwre2342werwrew'
>>> p = r'(\d*)([a-zA-Z]*)'
>>> m = re.match(p,s)
>>> m.group()
'23432werwre'
>>> m.group(0)
'23432werwre'
>>> m.group(1)
'23432'
>>> m.group(2)
'werwre'
>>> m.groups()
('23432', 'werwre')
>>> m = re.findall(p,s)
>>> m
[('23432', 'werwre'), ('2342', 'werwrew'), ('', '')]
>>> p=r'(\d+)'
>>> m=re.match(p,s)
>>> m.group()
'23432'
>>> m.group(0)
'23432'
>>> m.group(1)
'23432'
>>> m.groups()
('23432',)
>>> m=re.findall(p,s)
>>> m
['23432', '2342']
```
- `group()`：母串中与模式pattern匹配的子串；
- `group(0)`：结果与group()一样；
- `groups()`：所有group组成的一个元组，group(1)是与patttern中第一个group匹配成功的子- 串，group(2)是第二个，依次类推，如果index超了边界，抛出IndexError；
- `findall()`：返回的就是所有groups的数组，就是group组成的元组的数组，母串中的这一撮组成一个元组，那一措组成一个元组，这些元组共同构成一个list，就是findall()的返回结果。另，如果groups是只有一个元素的元组，findall的返回结果是子串的list，而不是元组的list了。
## 例子

```python
s ="1113446777"
```
用正则表达式把s分为1111, 3, 44, 6, 777

```python
import  re
s ="1113446777"
m=re.findall(r'(\d)\1*',s)
print(m)
#['1', '3', '4', '6', '7']

m = re.search(r'(\d)\1*',s)
print(m.group())        #111
print(m.groups())       #('1',)
print(m.groups(0))      #('1',)
print(m.groups(1))      #('1',)
>>> m.group(2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: no such group
>>> m=re.finditer(r'(\d)\1*',s)
>>> m.next().group()
'111'
>>> m.next().group()
'3'
>>> m.next().group()
'44'
>>> m.next().group()
'6'
>>> m.next().group()
'777'
>>> m.next().group()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

```python
>>> p = r'(\d)\1+([a-zA-Z]+)'
>>> s = '1111werwrw3333rertert4444'
>>> p = r'(\d)\1+([a-zA-Z]*)'
>>> import re
>>> re.findall(p,s)
[('1', 'werwrw'), ('3', 'rertert'), ('4', '')]
>>> m = re.search(p,s)
>>> m.group()
'1111werwrw'
>>> m.group(1)
'1'
>>> m.group(2)
'werwrw'
>>> m.groups()
('1', 'werwrw')
>>> m = re.finditer(p,s)
>>> m.next().group()
'1111werwrw'
>>> m.next().group()
'3333rertert'
>>> m.next().group()
'4444'
>>> m.next().group()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

1. **group([group1, …]):**
   获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。
2. **groups([default]):**
   以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。



参考

1. <a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" blank="">Python正则表达式指南</a> 